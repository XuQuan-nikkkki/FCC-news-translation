> * 原文地址：[Do You Solve Programming Problems or Complete Exercises? (The Difference Matters.) 程序员养成之面向问题编程](https://www.freecodecamp.org/news/do-you-solve-programming-problems-or-complete-exercises-the-difference-matters/)
> * 原文作者：Amy Haddad
> * 译者：
> * 校对者：

![Do You Solve Programming Problems or Complete Exercises? (The Difference Matters.)](https://www.freecodecamp.org/news/content/images/size/w2000/2020/02/amy-haddad-article.jpg)

People tend to use the terms “problems” and “exercises” interchangeably. But there’s a difference—and it matters.

Professor Paul Zeitz makes the distinction.

Take 5 × 5. That’s easy, and that’s an exercise. So is 5,490,900 × 496. It’s a bit harder and will take you more time to solve, but you know what to do. That’s the key point.

“An exercise is a mathematical question that you immediately know how to answer,” explains Zeitz in a  [lecture series on problem-solving][1]. “You may not answer it correctly, in fact you may never answer it correctly...but there’s no doubt about how to proceed.”

Not so with problems. A problem, according to Zeitz, “is a mathematical question that you do not know how to answer, at least initially.”

He defines problems and exercises through the lens of mathematical problem-solving, but they’re applicable to programming as well.

Each day we put our  [problem-solving][2]  skills to work as programmers: debugging code, learning a new topic, or even solving a problem. Exercises have their place, but as a programmer there’s no replacement for solving problems.

## Exercise with Exercises

There are two ways you can benefit from exercises. First, they’re helpful when learning a new topic.

I’m learning JavaScript right now and using a mix of exercises and problems to do so. The exercises help me see patterns and get comfortable with concepts and syntax.

Here’s an example of an exercise from a  [project][3]  that asked me to write a function, which took an array of cars.

```
const cars = [
  { id: 1, car_make: "Lincoln", car_model: "Navigator", car_year: 2009 },
  { id: 2, car_make: "Mazda", car_model: "Miata MX-5", car_year: 2001 },
  { id: 3, car_make: "Land Rover", car_model: "Defender Ice Edition", car_year: 2010 },
  ...
 ]

```

I had to sort the array of objects by the  `car_model`  key, in ascending order.

It’s not to say this exercise was a breeze—it wasn’t. It took me time and I got my fair share of error messages.

However, it qualifies as an exercise because I knew what I needed to do from the start.

I’d recently learned about arrays in JavaScript. I was familiar with sorting data from my experience with Python, though I had to research how to do this in JavaScript. The explicit directions helped, too.

But the concepts were still new. I needed practice putting them together, which is why this exercise was valuable. Repetition breeds familiarity, and the concepts began to solidify in my mind.

## Maintain What You’ve Gained

Exercises also help keep learned information fresh.

As I learn JavaScript, I don’t want to forget everything I’ve learned about the first language I learned, Python. So I use Anki, a flashcard program, multiple times per day.

In this context, exercises help you keep a mountain of material straight, remind you of important concepts, and get more comfortable using a particular data structure or approach. It’s maintenance work on the body of knowledge you’ve gained so far.

I have over 1,000 cards that are filled with material I’ve seen many times before. Some cards have questions about syntax. Others ask me to write SQL queries or command-line or Git commands. Many others are filled with exercises, like “rotate a list of numbers to the right by one place value.”

It’s important to note that this exercise was once a problem for me. If you do a problem enough, it can become an exercise. At the same time, you can make an exercise a problem by  [adding a constraint][4].

Exercises are a slippery slope. On the one hand, they’re useful for learning purposes. On the other, it’s easy to get comfortable by sticking with exercises exclusively.

That’s the downside: staying in your comfort zone.

## Dealing with Ambiguity

Programming is about problem-solving. And solving problems will take you  _outside_  of your comfort zone. This is a good thing.

For me, problems have two distinctive qualities. The first is ambiguity. Problem-solving is largely about how to effectively deal with ambiguity.  

-   An error message appears each time your program runs. Why? What’s going on? Where’s the bug? How can you fix it?
-   You pull up a new problem statement. You read it and re-read it. At first glance, you’ve got no idea what’s going on, let alone what you need to do to solve it. You may even get the “deer in headlights” sensation that’s accompanied by a pit in the bottom of your stomach. (You picked a good problem!)
-   You need to learn about relational databases. That’s pretty broad. How are you going to go about it? What to focus on first? What matters most? What do you really need to know right  _now_?

These examples all involve ambiguity. And all of them require solving  _problems_, whether that’s finding and trouble-shooting a bug, solving an actual problem, or learning a new topic.

To make progress, you research, experiment, pull out the facts, create a plan, and apply a variety of problem-solving tactics. In short, you learn to figure it out. The more time you spend with a problem and the  [different perspectives you gain][5], the more layers it reveals and the closer you get to the “aha” moment.

## Embrace the Struggle

The other difference with problems is the struggle. It’s real.

Problem-solving will test your mental stamina and patience. Progress can be slow, and the process tedious. I’ve toiled away at problems for hours, days, and even weeks.

It’s not to say that exercises won’t challenge you. They can. It’s one thing when you know that you need to use a particular method; you just need to get it to work properly. That’s a challenge, which can sometimes be downright frustrating.

But it’s something else entirely when you have no idea what to do from the start, which may happen multiple times when solving a problem. To me, problems are a struggle.

The best solution is to endure it and get yourself  [unstuck][6]. In my experience, the struggle means I’m learning a lot and the breakthrough is usually around the corner.

As you push through the mental discomfort, you’ll find yourself thinking creatively and devising solutions you never thought of before. (You surprise and impress yourself—you know more than you think!) You’re becoming a stronger programmer.

You’ll even find yourself having fun. Problem-solving is challenging, to be sure, and even frustrating at times. But it’s also incredibly rewarding.

It’s like crossing the finish line of a half-marathon. No doubt the past 13.1 miles were grueling, but crossing the finish line was worth it and I’d do it again. Solving a problem feels the same way.

## Which Is It: Problems or Exercises?

When you crack open your laptop, are you going to solve problems or complete exercises?

Exercises have benefits, and it’s fine to incorporate them into your programming sessions. I use exercises as a warm-up prior to a programming session. I’ll flip through an Anki flashcard deck for ten or fifteen minutes and work through some exercises. If I’m learning something new, like JavaScript, I may have an entire programming session devoted to exercises.

However, I devote time each day to solving  _problems_—no matter what else I’m learning or building. Even on the days when I allocate a large chunk of time to exercises, I allocate plenty of time to solving problems, too.

So when you’re about to start a programming session, be aware what you’re setting out to do: exercises or problems. And no matter what, make time for solving problems.

Problem-solving is a skill that takes a lot of practice and time to develop. The only way to get better is to work at it each day. It’s that important, and for good reason.

We solve problems each day as programmers, and in a variety of ways. Making time to problem-solve is a no-brainer; our work as programmers depends on it.

[1]: https://www.thegreatcoursesplus.com/show/art_and_craft_of_mathematical_problem_solving
[2]: https://www.freecodecamp.org/news/how-to-be-a-great-programmer-34939494996d/
[3]: https://github.com/LambdaSchool/JS-Exercise-Functions-Arrays-Objects
[4]: https://www.freecodecamp.org/news/why-i-recycle-programming-problems-7785e04e451d/
[5]: https://amymhaddad.com/the-art-of-problem-solving
[6]: https://www.freecodecamp.org/news/how-to-get-unstuck/
